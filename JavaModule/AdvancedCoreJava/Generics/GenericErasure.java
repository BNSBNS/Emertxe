/**
 * ref: https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html
 * 
 * To implement generics, the Java compiler applies type erasure to:
 * -> Replace all type parameters in generic types with their bounds or Object 
 * if the type parameters are unbounded. The produced bytecode, 
 * therefore, contains only ordinary classes, interfaces, and methods.
 * -> Insert type casts if necessary to preserve type safety.
 * -> Generate bridge methods to preserve polymorphism in extended 
 * generic types.
 * 
 * Type erasure ensures that no new classes are created for parameterized types;
 *  consequently, generics incur no runtime overhead.
 *  
 *  Bridge method:
 *  When compiling a class or interface that extends a parameterized class
 *   or implements a parameterized interface, the compiler may need to create a 
 *   synthetic method, called a bridge method, as part of the type erasure process.
 *   
 *    NOTE:
 *    Restrictions on Generics
 *    ---> Cannot Instantiate Generic Types with Primitive Types
 *    ---> Cannot Create Instances of Type Parameters
 *    ---> Cannot Declare Static Fields Whose Types are Type Parameters
 *    ---> Cannot Use Casts or instanceof With Parameterized Types
 *    ---> Cannot Create Arrays of Parameterized Types
 *    ---> Cannot Create, Catch, or Throw Objects of Parameterized Types
 *    ---> Cannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type
 */

package com.nanditha.AdvancedCoreJava.Generics;

class Node {

    public Object data;

    public Node(Object data) { 
    	this.data = data; 
    }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

class MyNode extends Node {

    public MyNode(Object data) {
		super(data);
	}

	// Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}

public class GenericErasure {
	
	public static void main(String[] args) {
		MyNode mn = new MyNode(5);
		Node n = mn;
		//n.setData("ClassCastException"); 
		n.setData(12); 
		/*
		 * n.setData("Hello"); causes the method setData(Object)
		 *  to be executed on the object of class MyNode.
		 *   (The MyNode class inherited setData(Object) from Node.)
		 *   
		 *   In the body of setData(Object), 
		 *   the data field of the object referenced by n is assigned to a String.
		 *   
		 *   The data field of that same object, referenced via mn,
		 *    can be accessed and is expected to be an integer 
		 *    (since mn is a MyNode which is a Node<Integer>.
		 *    
		 *    Trying to assign a String to an Integer causes a 
		 *    ClassCastException from a cast inserted at the assignment 
		 *    by a Java compiler.
		 */
		//Integer x = (String) mn.data; 
		Integer x = (Integer) mn.data; 
	}
	
}
